# Mindsnap团队的电影推荐系统 - 项目文档

**项目GitHub地址:** [https://github.com/Boulea7/Movie_recommender_wechat](https://github.com/Boulea7/Movie_recommender_wechat)

**文档版本:** 1.2
**最后更新日期:** (由AI助手填写实际日期)
**撰写人:** AI助手 (基于用户指令和项目代码)

## 0. 项目概述

### 0.1 项目简介
本项目旨在根据用户历史行为数据，利用机器学习算法（主要是协同过滤和基于内容的推荐），为用户提供个性化的电影推荐。系统将通过微信公众号与用户进行交互，用户可以搜索电影、评价电影，并获取个性化推荐。

### 0.2 项目目标
1.  搭建一个功能完整的电影推荐系统后端服务。
2.  实现基于用户的协同过滤推荐算法。
3.  实现基于内容的推荐算法以解决冷启动问题。
4.  通过微信公众号平台，提供用户友好的交互界面。
5.  确保系统在阿里云Ubuntu服务器上稳定部署和运行。

### 0.3 技术栈
*   **后端语言:** Python 3.9+
*   **Web框架:** web.py 0.62
*   **数据库:** MySQL 8.0
*   **Python库:**
    *   `pymysql`: 数据库连接
    *   `web.py`: Web框架
    *   `lxml` (隐式依赖，由微信消息XML处理的`xml.etree.ElementTree`替代，但若涉及复杂解析可能需要)
    *   `cryptography` (隐式依赖，由微信签名验证的`hashlib`替代，若涉及消息加解密则需要)
*   **服务器:** 阿里云ECS，Ubuntu 20.04 LTS或更高版本
*   **前端交互:** 微信公众号平台

### 0.4 项目范围
1.  **用户管理:**
    *   新用户关注公众号时自动注册（记录微信用户OpenID）。
    *   发送使用说明给新关注用户。
2.  **电影信息管理:**
    *   存储电影基本信息（ID、名称、评分、演员、简介等）。
    *   （初期）手动填充至少200条详细的电影测试数据。
3.  **核心交互功能 (通过微信公众号文本消息):**
    *   **搜索电影:** 用户输入电影名，返回电影详细信息（支持精确和模糊搜索）。
    *   **评价电影:** 用户输入"评价 电影名 评分"，记录用户评分。
    *   **获取推荐:** 用户输入"推荐"，返回个性化电影列表。
4.  **推荐算法:**
    *   **基于用户的协同过滤 (User-CF):** 作为主要的推荐算法。
    *   **基于内容的推荐 (Content-Based):** 作为冷启动或协同过滤无结果时的补充。
    *   **混合推荐策略:** 结合User-CF和Content-Based的结果。
5.  **系统部署:**
    *   在阿里云Ubuntu服务器上部署。
    *   编写详细的部署脚本和手动部署指南。

## 1. 环境准备与配置

### 1.1 本地开发环境
*   **Python:** 安装Python 3.9+，并配置好pip。
*   **虚拟环境:** 强烈建议使用虚拟环境。
    ```bash
    python3 -m venv .venv
    source .venv/bin/activate  # Linux/macOS
    # .venv\Scripts\activate    # Windows
    pip install web.py pymysql # 其他库如requests, lxml, cryptography 根据实际需要添加
    ```
*   **MySQL服务器:**
    *   **版本:** MySQL 8.0 或兼容版本。
    *   **用户:** 创建一个专门用于本项目的数据库用户。
        *   用户名: `movie_rec_user`
        *   密码: `MovieRecDbP@ssw0rd` (请在实际部署时使用更安全的密码，并配置在环境变量或配置文件中)
    *   **数据库:** 创建一个数据库。
        *   数据库名: `movie_recommendation_system`
        *   字符集: `utf8mb4`
*   **Git:** 安装Git，用于版本控制。

### 1.2 阿里云服务器 (Ubuntu)
*   **操作系统:** Ubuntu 20.04 LTS 或更高版本。
*   **实例配置:** 至少1核CPU, 1GB RAM (根据预算和预期负载调整)。
*   **安全组配置:**
    *   开放TCP端口 `22` (用于SSH)。
    *   开放TCP端口 `80` (用于微信公众号HTTP接入，或Nginx反代后的端口)。
    *   (可选) 开放TCP端口 `3306` (如果MySQL部署在云服务器上且本地需要访问，但不推荐公网暴露3306，建议通过SSH隧道或仅限服务器内部访问)。
*   **必备软件安装 (在服务器上执行):**
    ```bash
    sudo apt update
    sudo apt install -y python3-pip python3-venv git nginx # Nginx用于反向代理和HTTPS
    # MySQL Server (如果数据库也部署在这台服务器上)
    # sudo apt install -y mysql-server
    # sudo mysql_secure_installation # 进行安全配置
    ```

### 1.3 微信公众号配置
*   **类型:** 个人订阅号或服务号 (个人订阅号权限受限，但符合论文描述)。
*   **开发者基本配置:**
    *   **服务器地址(URL):** `http://YOUR_SERVER_IP_OR_DOMAIN/` (注意：末尾必须有 `/`)
    *   **令牌(Token):** `HelloMindsnap` (与 `app/config.py` 中 `WECHAT_TOKEN` 一致)
    *   **消息加解密密钥(EncodingAESKey):** 根据微信后台生成填写 (如果选择安全模式)
    *   **消息加解密方式:** 根据需要选择，通常为"安全模式"或"明文模式"。
*   **开发者文档:** [https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html](https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html)

### 1.4 GitHub仓库
*   **地址:** `https://github.com/Boulea7/Movie_recommender_wechat`
*   本地项目初始化后，关联此远程仓库。

## 2. 系统设计

### 2.1 架构设计
系统遵循经典的微信公众号后台服务架构：
1.  **用户端:** 微信用户通过微信公众号发送请求。
2.  **微信服务器:** 作为消息中转，将用户消息POST到我们配置的后端服务器URL，并将后端服务器的响应返回给用户。
3.  **后端应用服务器 (web.py):**
    *   监听指定端口（如80或8080），处理微信服务器转发过来的HTTP请求。
    *   解析XML格式的用户消息。
    *   根据消息内容执行相应逻辑（搜索、评价、推荐）。
    *   与MySQL数据库交互，读取和存储数据。
    *   执行推荐算法。
    *   构造XML格式的响应消息返回给微信服务器。
4.  **数据库 (MySQL):** 存储电影信息、用户信息、用户评分、搜索记录等。

### 2.2 代码结构与模块组成

项目核心代码位于 `app` 目录下：

```
Movie_Recommender_WeChat/
├── app/
│   ├── __init__.py             # 包初始化文件，定义app为Python包
│   ├── main.py                 # Web应用主入口，处理HTTP请求和路由
│   ├── config.py               # 配置文件，存储数据库连接、微信Token等
│   ├── wechat_handler.py       # 微信消息处理器，解析、处理、响应微信消息
│   ├── db_manager.py           # 数据库管理器，封装所有数据库操作
│   ├── recommendation_engine.py # 推荐引擎，实现推荐算法
│   └── utils.py                # 工具模块 (当前预留)
├── deploy.sh                   # 部署脚本
├── requirements.txt            # Python依赖包列表
├── README.md                   # 项目说明文档
└── ... (其他项目文件)
```

#### 2.2.1 `app/config.py` - 配置文件

*   **功能:** 集中管理项目的所有配置参数，方便修改和维护，避免硬编码。
*   **实现原理:** 定义Python字典或变量存储配置项。
*   **主要配置内容:**
    *   `DB_CONFIG`: 数据库连接参数（主机、用户、密码、数据库名、字符集、游标类型）。
        ```python
        DB_CONFIG = {
            'host': 'localhost',  # 数据库服务器地址
            'user': 'movie_rec_user',  # 数据库用户名
            'password': 'MovieRecDbP@ssw0rd',  # 数据库密码
            'db': 'movie_recommendation_system',  # 数据库名
            'charset': 'utf8mb4',  # 字符集
            'cursorclass': 'pymysql.cursors.DictCursor' # 使查询结果为字典形式
        }
        ```
    *   `WECHAT_TOKEN`: 微信公众号后台配置的Token，用于验证请求来源的真实性。
        ```python
        WECHAT_TOKEN = "HelloMindsnap"
        ```
    *   推荐系统参数：
        *   `DEFAULT_RECOMMENDATIONS_COUNT`: 默认情况下，一次向用户推荐的电影数量。
        *   `MAX_SEARCH_RESULTS`: 当用户进行模糊电影搜索时，返回的最大电影条目数，以避免消息过长。
        *   `SIMILAR_USERS_COUNT`: 在基于用户的协同过滤算法中，选取的与目标用户最相似的用户（邻居）的数量。
        *   `MIN_COMMON_RATINGS`: 在计算用户间相似度时，两个用户至少共同评价过的电影数量。此参数过小可能导致相似度不准确，过大则可能找不到足够的相似用户。
        ```python
        DEFAULT_RECOMMENDATIONS_COUNT = 3
        MAX_SEARCH_RESULTS = 3
        SIMILAR_USERS_COUNT = 10
        MIN_COMMON_RATINGS = 2
        ```
*   **使用方式:** 其他模块（如 `app/db_manager.py`, `app/wechat_handler.py`）通过 `from app.config import DB_CONFIG, WECHAT_TOKEN` 等方式导入这些配置项并使用。这使得配置的修改只需要在一处进行，提高了代码的可维护性。

#### 2.2.2 `app/main.py` - Web应用主入口

*   **功能:**
    1.  **初始化web.py应用:** 创建web.py应用实例，是整个后台服务的起点。
    2.  **定义URL路由规则:** 将特定路径的HTTP请求（目前主要是根路径 `/`）导向到相应的处理类 (`WeChatInterface`)。
    3.  **处理微信服务器请求:**
        *   **GET请求:** 用于微信公众号配置时的服务器有效性验证。
        *   **POST请求:** 用于接收微信服务器转发的用户发送给公众号的各类消息（文本、事件等）。
    4.  **配置和启动日志系统:** 初始化`logging`模块，用于记录应用运行状态、请求信息、错误等，便于调试和监控。
    5.  **应用启动逻辑:** 包含解析命令行参数以支持指定监听端口，并最终运行web.py应用服务器。
*   **实现原理:**
    *   **web.py框架:** 利用其轻量级的特性快速搭建Web服务。
    *   **类处理请求:** 定义一个类（`WeChatInterface`）来封装对HTTP GET和POST方法的处理逻辑。
    *   **模块化导入:** 从项目其他模块（如`app.wechat_handler`处理具体消息，`app.config`获取配置）导入所需功能。
*   **关键代码逻辑:**
    *   **Python路径设置与模块导入:**
        确保项目根目录被添加到`sys.path`，使得`app`包内的模块可以被正确导入。
        ```python
        import sys
        import os
        project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        sys.path.insert(0, project_root)
        from app import wechat_handler
        from app.config import WECHAT_TOKEN
        ```
    *   **日志配置:**
        使用`logging.basicConfig`设置全局日志级别和格式。
        ```python
        import logging
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
        logger = logging.getLogger(__name__)
        ```
    *   **URL路由定义:**
        将所有发往根路径`/`的请求都由`WeChatInterface`类处理。
        ```python
        urls = ('/', 'WeChatInterface')
        ```
    *   **`WeChatInterface`类:**
        *   `GET()`方法: (微信服务器验证逻辑)
            *   通过`web.input()`获取微信服务器发送的`signature`, `timestamp`, `nonce`, `echostr`参数。
            *   调用`wechat_handler.check_signature()`方法（传入获取的参数和`WECHAT_TOKEN`）进行签名验证。
            *   如果验证成功，直接返回`echostr`给微信服务器，表示对接成功。
            *   如果验证失败或发生异常，记录日志并返回错误提示信息。
            ```python
            class WeChatInterface:
                def GET(self):
                    try:
                        params = web.input()
                        signature = params.signature
                        timestamp = params.timestamp
                        nonce = params.nonce
                        echostr = params.echostr
                        logger.info(f"收到验证请求: signature={signature}, timestamp={timestamp}, nonce={nonce}")
                        if wechat_handler.check_signature(signature, timestamp, nonce, WECHAT_TOKEN):
                            logger.info("验证成功")
                            return echostr
                        else:
                            logger.warning("验证失败")
                            return "验证失败"
                    except Exception as e:
                        logger.error(f"验证请求处理异常: {e}")
                        return "请求处理异常"
            ```
        *   `POST()`方法: (接收用户消息逻辑)
            *   通过`web.data()`获取微信服务器POST过来的原始XML消息体。
            *   将接收到的XML数据传递给`wechat_handler.handle_wechat_message()`进行后续的解析、业务处理和响应构建。
            *   将`handle_wechat_message()`返回的XML响应字符串直接返回给微信服务器。
            *   处理过程中若发生异常，记录错误日志并返回通用错误提示。
            ```python
            # (在 WeChatInterface 类中)
                def POST(self):
                    try:
                        xml_data = web.data()
                        logger.info(f"收到用户消息: {xml_data.decode('utf-8')}")
                        response = wechat_handler.handle_wechat_message(xml_data)
                        logger.info(f"返回响应: {response}")
                        return response
                    except Exception as e:
                        logger.error(f"处理用户消息异常: {e}")
                        return "处理用户消息异常"
            ```
    *   **应用启动 (`if __name__ == "__main__":`)**
        *   允许通过命令行参数`sys.argv[1]`指定监听端口，若未提供或提供无效则使用默认端口8080。
        *   **重要:** `web.py 0.62`版本通过向`sys.argv`添加端口号字符串来指定监听端口，而不是通过`app.run(port=...)`。
        *   创建`web.application`实例，传入URL路由表和全局命名空间 (`globals()`)。
        *   调用`app.run()`启动Web服务并开始监听请求。
        ```python
        if __name__ == "__main__":
            args = sys.argv
            port_to_listen = 8080
            if len(args) > 1:
                try:
                    port_to_listen = int(args[1])
                except ValueError:
                    logger.warning(f"无效的端口参数: {args[1]}，使用默认端口: {port_to_listen}")
            
            sys.argv = [args[0]] # 清理原参数，web.py会自行解析
            sys.argv.append(str(port_to_listen)) # 添加端口参数
            
            logger.info(f"启动微信电影推荐系统服务，监听端口: {port_to_listen}")
            try:
                app = web.application(urls, globals())
                app.run()
            except Exception as e:
                logger.error(f"应用启动失败: {e}")
                sys.exit(1)
        ```
*   **交互与依赖:**
    *   依赖 `web.py` 框架。
    *   调用 `app.wechat_handler` 处理微信消息的具体逻辑。
    *   使用 `app.config` 获取 `WECHAT_TOKEN`。
    *   与 `logging` 模块交互记录日志。

#### 2.2.3 `app/wechat_handler.py` - 微信消息处理器

*   **功能:** 核心的微信消息业务逻辑处理中心。
    1.  验证微信请求签名。
    2.  解析接收到的XML消息。
    3.  根据消息类型（文本、事件）和内容，分发到不同的处理函数。
    4.  调用数据库模块和推荐引擎模块完成具体业务。
    5.  构建XML格式的响应消息。
*   **实现原理:**
    *   使用`xml.etree.ElementTree`进行XML的解析和构建。
    *   使用`hashlib`进行SHA1加密以验证签名。
    *   通过一系列`if-elif-else`语句判断消息类型和内容，实现逻辑分发。
*   **关键函数与逻辑:**
    *   `check_signature(signature, timestamp, nonce, token)`: 签名验证。
        *   将`token`, `timestamp`, `nonce`排序。
        *   拼接成字符串后进行SHA1哈希。
        *   与传入的`signature`对比。
        ```python
        def check_signature(signature, timestamp, nonce, token=WECHAT_TOKEN):
            try:
                temp_list = [token, timestamp, nonce]
                temp_list.sort()
                temp_str = ''.join(temp_list)
                hash_str = hashlib.sha1(temp_str.encode('utf-8')).hexdigest()
                return hash_str == signature
            except Exception as e:
                logger.error(f"签名验证失败: {e}")
                return False
        ```
    *   `parse_xml_message(xml_data)`: 解析XML，将XML节点转换为字典。
        ```python
        def parse_xml_message(xml_data):
            try:
                root = ET.fromstring(xml_data)
                msg_dict = {}
                for child in root:
                    msg_dict[child.tag] = child.text
                return msg_dict
            except Exception as e:
                logger.error(f"XML解析失败: {e}")
                return {}
        ```
    *   `build_text_response(to_user, from_user, content)`: 构建文本类型的XML响应。
        ```python
        def build_text_response(to_user, from_user, content):
            response = f"""<xml>
            <ToUserName><![CDATA[{to_user}]]></ToUserName>
            <FromUserName><![CDATA[{from_user}]]></FromUserName>
            <CreateTime>{int(time.time())}</CreateTime>
            <MsgType><![CDATA[text]]></MsgType>
            <Content><![CDATA[{content}]]></Content>
        </xml>"""
            return response
        ```
    *   `handle_wechat_message(xml_data)`: 消息处理总入口。这是此模块最核心的函数，协调所有消息处理流程。
        1.  **接收与解析:** 调用 `parse_xml_message(xml_data)` 将原始XML数据转换为Python字典 `msg`。
        2.  **提取基本信息:** 从 `msg` 字典中获取 `FromUserName` (用户OpenID), `ToUserName` (公众号原始ID), 和 `MsgType` (消息类型)。
        3.  **文本消息处理 (`if msg_type == 'text':`)**: 
            *   获取文本内容 `content = msg.get('Content', '').strip()`。
            *   **推荐请求:** 如果 `content == "推荐"`，则调用 `handle_movie_recommendation(from_user)` 处理推荐逻辑。
            *   **评价请求:** 如果 `content.startswith("评价 ")`，则调用 `handle_movie_rating(from_user, content)` 处理评价逻辑。
            *   **搜索请求 (默认):** 其他所有文本消息都视为电影搜索请求，调用 `handle_movie_search(from_user, content)`。
            *   将上述处理函数返回的文本内容包装成XML响应。
        4.  **事件消息处理 (`elif msg_type == 'event':`)**: 
            *   获取事件类型 `event = msg.get('Event')`。
            *   **关注事件 (`if event == 'subscribe':`)**: 
                *   调用 `db_manager.get_user_id_by_openid(from_user)` 确保用户在数据库中存在（如果不存在则会创建）。
                *   构建包含欢迎语和使用说明的 `welcome_msg`。
                *   将 `welcome_msg` 包装成XML响应。
            *   **取消关注事件 (`elif event == 'unsubscribe':`)**: 
                *   记录日志 `logger.info(f"用户 {from_user} 取消关注")`。
                *   微信规定取消关注事件不需要回复，因此返回空字符串 `""`。
            *   **其他事件:** 回复"暂不支持此类型的事件"。
        5.  **其他消息类型:** 如果消息类型不是文本或事件，回复"暂只支持文本消息，请发送文字"。
        6.  **异常处理:** 整个处理流程包裹在 `try-except` 块中，任何未预料的错误都会被捕获，记录日志，并返回通用错误提示 "处理请求失败"。
        ```python
        # 关键逻辑结构示意
        def handle_wechat_message(xml_data):
            try:
                msg = parse_xml_message(xml_data)
                # ... (提取 from_user, to_user, msg_type)
                if msg_type == 'text':
                    content = msg.get('Content', '').strip()
                    if content == "推荐":
                        response_content = handle_movie_recommendation(from_user)
                    elif content.startswith("评价 "):
                        response_content = handle_movie_rating(from_user, content)
                    else:
                        response_content = handle_movie_search(from_user, content)
                    return build_text_response(from_user, to_user, response_content)
                elif msg_type == 'event':
                    event = msg.get('Event')
                    if event == 'subscribe':
                        # ... (处理关注，回复欢迎语)
                    elif event == 'unsubscribe':
                        return "" # 无需回复
                # ... (其他情况)
            except Exception as e:
                logger.error(f"处理消息失败: {e}")
                return "处理请求失败"
        ```
    *   `handle_movie_search(from_user_openid, movie_title)`: 处理电影搜索请求。
        1.  清理用户输入的 `movie_title` (去除首尾空格)。
        2.  调用 `db_manager.get_user_id_by_openid(from_user_openid)` 获取或创建用户ID。
        3.  调用 `db_manager.log_search_query(user_id, cleaned_movie_title)` 记录搜索行为。
        4.  **精确匹配:** 首先尝试 `db_manager.search_movies_by_title_exact(cleaned_movie_title)`。
        5.  **模糊匹配:** 如果精确匹配无结果，则尝试 `db_manager.search_movies_by_title_fuzzy(cleaned_movie_title, limit=MAX_SEARCH_RESULTS * 2)`。这里 `limit` 设置为 `MAX_SEARCH_RESULTS * 2` 是为了获取稍多一些的结果，交由后续的 `get_movie_details_for_display` 函数根据实际消息长度限制进行最终筛选。
        6.  **结果格式化与长度控制:**
            *   如果精确或模糊搜索均无结果，返回 "抱歉，未找到..." 的提示。
            *   否则，调用 `db_manager.get_movie_details_for_display(movies_to_display, max_movies_to_display=MAX_SEARCH_RESULTS)` 将电影数据格式化为文本。此函数内部会处理单部电影简介长度、显示电影数量和最终消息总长度，确保不超过微信限制。
            *   如果搜索结果较多，会附加提示信息，如 "已显示前X部" 或 "模糊搜索到多个结果，已显示评分较高的前X部"。
            *   最终返回格式化后的电影信息字符串。
    *   `handle_movie_rating(from_user_openid, content)`: 处理电影评分请求。
        1.  **命令解析:** 使用正则表达式 `pattern = r'^评价\\s+(.+)\\s+(\\d+(\\.\\d)?)$'` 从 `content` 中提取电影名称和评分。如果格式不匹配，返回格式错误提示。
        2.  **评分校验:** 将提取的评分字符串转换为浮点数。如果评分 `< 0`，则修正为 `0`；如果 `> 10`，则修正为 `10`。并在回复中注明已调整。
        3.  调用 `db_manager.get_user_id_by_openid(from_user_openid)` 获取用户ID。
        4.  **查找电影:** 调用 `db_manager.search_movies_by_title_exact(movie_name)` 查找电影。
            *   如果未找到电影，返回 "未找到电影《...》，无法评价"。
            *   **同名电影处理:** 如果找到多部同名电影，当前版本简单地选择第一部 (`movies[0]`) 进行评价，并在回复中提示用户注意这一点。
        5.  **存储评分:** 调用 `db_manager.add_or_update_rating(user_id, movie_id, score)` 将评分存入数据库。此函数会自动处理是新增评分还是更新已有评分。
        6.  返回评分成功或失败的提示。
    *   `handle_movie_recommendation(from_user_openid)`: 处理电影推荐请求。
        1.  调用 `db_manager.get_user_id_by_openid(from_user_openid)` 获取用户ID。
        2.  **用户评分检查:** 调用 `db_manager.get_user_ratings(user_id)` 获取用户已有的评分记录数量 `ratings_count`。
            *   如果 `ratings_count == 0`，返回提示信息，引导用户先评价几部电影，因为没有评分数据无法进行个性化推荐。
            *   如果 `ratings_count < 3` (一个可配置的阈值)，在推荐结果前附加一条提示，说明由于评分较少，推荐可能不够个性化，鼓励用户多评价。
        3.  **调用推荐引擎:** 调用 `recommendation_engine.generate_recommendations(user_id, DEFAULT_RECOMMENDATIONS_COUNT)` 获取推荐的电影ID列表。`DEFAULT_RECOMMENDATIONS_COUNT` 来自配置文件，定义了单次推荐的电影数量。
        4.  **处理推荐结果:**
            *   如果推荐引擎返回空列表 (可能因为数据不足或算法未能找到合适的推荐)，返回相应的提示信息给用户。
            *   如果获取到电影ID列表，遍历列表，对每个 `movie_id` 调用 `db_manager.get_movie_by_id(movie_id)` 获取电影的详细信息。
            *   将获取到的电影信息列表传递给 `db_manager.get_movie_details_for_display(movies_info, max_movies_to_display=DEFAULT_RECOMMENDATIONS_COUNT)` 进行格式化，逻辑与搜索结果的格式化类似，确保消息内容适合微信展示且不超过长度限制。
            *   最终返回包含推荐电影信息的文本字符串。
*   **交互与依赖:**
    *   依赖 `xml.etree.ElementTree`, `time`, `hashlib`, `logging`, `re` 标准库。
    *   依赖项目内部模块: `app.config` (获取微信Token、搜索和推荐参数), `app.db_manager` (执行所有数据库操作), `app.recommendation_engine` (调用推荐算法)。

#### 2.2.4 `app/db_manager.py` - 数据库管理器

*   **功能:** 封装所有与数据库交互的操作，提供清晰的数据访问接口给其他模块。
    1.  管理数据库连接。
    2.  实现用户、电影、评分、搜索记录的CRUD（创建、读取、更新、删除）操作。
    3.  提供推荐算法所需的数据提取函数。
*   **实现原理:**
    *   使用`pymysql`库连接MySQL数据库。
    *   每个数据库操作都封装在一个函数中，包含获取连接、执行SQL、处理结果、关闭连接的完整流程。
    *   使用`try-except`以及`with conn.cursor() as cursor:`语句块来确保数据库连接在操作完成后或发生异常时能被正确关闭。
    *   使用参数化查询（如`cursor.execute(sql, params)`）防止SQL注入风险。
*   **关键函数与逻辑:**
    *   `get_db_connection()`: 创建并返回数据库连接。此函数从`app.config.DB_CONFIG`读取配置，并特别处理`cursorclass`（确保其为实际的`pymysql.cursors.DictCursor`类而非字符串），以便查询结果以字典形式返回，方便按字段名访问数据。
        ```python
        def get_db_connection():
            try:
                config = DB_CONFIG.copy() # 避免修改全局配置
                if 'cursorclass' in config and isinstance(config['cursorclass'], str):
                    if config['cursorclass'] == 'pymysql.cursors.DictCursor':
                        config['cursorclass'] = pymysql.cursors.DictCursor
                conn = pymysql.connect(**config)
                return conn
            except Exception as e:
                logger.error(f"数据库连接失败: {e}")
                raise # 将异常向上抛出，以便调用者处理
        ```
    *   **用户管理:**
        *   `get_user_by_openid(openid)`: 根据微信OpenID查询`users`表，返回用户信息字典或`None`。
        *   `create_user(openid, nickname=None)`: 在`users`表中插入一条新的用户记录。`nickname`是可选的。成功后返回新创建用户的`id`。
        *   `get_user_id_by_openid(openid)`: 这是一个便捷函数，它首先尝试通过`get_user_by_openid`获取用户。如果用户存在，则返回其ID；如果不存在，则调用`create_user`创建新用户并返回新ID。这是系统中处理用户身份的核心入口。
    *   **电影管理:**
        *   `get_movie_by_id(movie_id)`: 根据电影`id`从`movies`表查询电影的完整信息。
        *   `search_movies_by_title_exact(title)`: 根据电影标题进行精确匹配搜索 (`WHERE title = %s`)。
        *   `search_movies_by_title_fuzzy(title, limit=5)`: 根据电影标题进行模糊匹配搜索 (`WHERE title LIKE %s`)，结果按`douban_rating`降序排列，并限制返回数量。
        *   `get_movie_details_for_display(movie_records, max_movies_to_display=3, max_total_chars=580)`: 核心的电影信息格式化函数。负责将从数据库获取的电影记录（单个或列表）转换为适合在微信中显示的文本字符串。
            *   **输入:** 电影记录（字典或字典列表），最大显示电影数，消息总字符数上限。
            *   **处理逻辑:**
                1.  遍历电影记录，但最多处理 `max_movies_to_display` 部。
                2.  对每部电影，提取标题、评分、年代、类型和剧情简介。
                3.  **智能截断简介:** `plot_summary` 会被截断到预设的 `PLOT_SUMMARY_MAX_LENGTH` (例如60字符)，并在末尾添加 "..." 以示省略。如果简介本身较短则不加。
                4.  **控制总长度:** 动态计算已生成文本的长度。在添加下一部电影信息前，会预估加入后的总长度是否会超过 `max_total_chars`。如果即将超长：
                    *   如果当前还没有任何电影信息被加入（即第一部电影就可能导致超长），会尝试一个"极简模式"，进一步缩短简介，只显示标题、评分和极简简介，看是否能在此限制内显示。
                    *   如果已有部分电影信息，且再加一部会导致超长，则会在当前结果末尾添加 "..." 符号，暗示还有更多内容，并停止添加更多电影。
                5.  多部电影的信息用双换行符 `"\n\n"` 分隔。
            *   **输出:** 格式化后的、适合微信展示的文本字符串。
            *   **健壮性:** 函数内部有对输出总长度的最终检查，以防意外超长，并记录警告。
    *   **评分管理:**
        *   `add_or_update_rating(user_id, movie_id, score)`: 添加或更新用户对电影的评分。核心逻辑是先根据 `user_id` 和 `movie_id` 查询 `ratings` 表中是否已存在评分记录。
            *   如果存在 (`existing_rating` is not None)，则执行 `UPDATE ratings SET score = %s, rated_at = NOW() WHERE user_id = %s AND movie_id = %s`。
            *   如果不存在，则执行 `INSERT INTO ratings (user_id, movie_id, score) VALUES (%s, %s, %s)`。
            *   评分 `score` 在传入前已经被`wechat_handler`验证和调整过范围 (0-10)。
        *   `get_user_ratings(user_id)`: 获取特定用户的所有评分记录，主要用于协同过滤算法。返回包含 `movie_id` 和 `score` 的字典列表。
        *   `get_all_user_ratings()`: 获取系统中所有用户的全部评分数据，是协同过滤算法的主要数据源。返回一个字典，键是 `user_id`，值是该用户的评分列表（每个元素是包含 `movie_id` 和 `score` 的字典）：`{user_id1: [{'movie_id': X, 'score': Y}, ...], user_id2: [...]}`。
        *   `get_movies_rated_by_user(user_id)`: 获取指定用户已经评分过的所有电影的ID列表。主要用于在推荐时排除用户已看过的电影。
    *   **推荐辅助:**
        *   `get_movies_for_content_based_recommendation(exclude_movie_ids=None, limit=100)`: 为基于内容的推荐算法提供候选电影。它会从 `movies` 表中选取豆瓣评分较高 (`ORDER BY douban_rating DESC`) 的电影，并可以通过 `exclude_movie_ids` 参数排除用户已经评分过的电影。返回电影记录列表。
    *   **搜索记录:**
        *   `log_search_query(user_id, search_query)`: 将用户的搜索关键词记录到 `search_logs` 表中。这是一个可选功能，用于数据分析和未来可能的搜索优化。
*   **交互与依赖:**
    *   依赖 `pymysql` 库进行数据库交互。
    *   依赖 `app.config` 获取 `DB_CONFIG`。
    *   被 `app.wechat_handler` 和 `app.recommendation_engine` 调用以执行数据存取。

#### 2.2.5 `app/recommendation_engine.py` - 推荐引擎

*   **功能:** 实现核心的电影推荐算法。
    1.  基于用户的协同过滤 (User-CF)。
    2.  基于内容的推荐 (主要用于冷启动和补充)。
    3.  混合推荐策略，结合上述两种算法的结果。
*   **实现原理:**
    *   **User-CF (`get_user_cf_recommendations`):**
        1.  **数据准备:** 
            *   调用 `db_manager.get_user_ratings(target_user_id)` 获取目标用户的评分记录 (格式: `[{'movie_id': mid, 'score': s}, ...]`)。
            *   调用 `db_manager.get_all_user_ratings()` 获取所有用户的评分数据 (格式: `{uid1: [{'movie_id': mid, 'score': s}, ...], ...}`).
            *   将目标用户和其他用户的评分记录都转换为字典形式 `{movie_id: score}`，便于快速查找电影评分。
        2.  **计算用户相似度:**
            *   遍历 `all_user_ratings` 中的每一个其他用户 `other_user_id`。
            *   找出目标用户和 `other_user_id` 都评分过的电影集合 `common_movies` (通过集合的交集操作 `set(target_keys) & set(other_keys)`)。
            *   **最小共同评分数过滤:** 如果 `len(common_movies)` 小于配置文件中的 `MIN_COMMON_RATINGS` (例如2)，则认为这两个用户共同评分的电影太少，相似度计算不可靠，跳过此 `other_user_id`。
            *   **相似度计算公式 (基于评分差平方，源自论文思路):**
                *   计算评分差的平方和: `sum_squared_diff = Σ (target_user_ratings_dict[movie_id] - other_user_ratings_dict[movie_id]) ** 2`，其中求和针对所有 `common_movies` 中的 `movie_id`。
                *   计算平均差异值: `area = sum_squared_diff / len(common_movies)`。这个 `area` 值越小，表示两个用户对共同电影的评分差异越小，即越相似。
                *   将差异值转换为相似度: `similarity = 1 / (1 + area)`。这样处理后，`similarity` 值越大表示越相似，范围在 (0, 1] 之间。如果两个用户对共同电影的评分完全一致，则 `area = 0`, `similarity = 1`。
            *   存储计算得到的相似度及其他相关信息: `user_similarity[other_user_id] = {'similarity': similarity, 'common_movies': len(common_movies), 'ratings': other_user_ratings_dict}`。
        3.  **选取Top-N邻居:**
            *   将 `user_similarity` 字典按 `similarity` 值进行降序排序。
            *   选取前 `SIMILAR_USERS_COUNT` (来自配置文件，例如10) 个用户作为目标用户的"邻居"。
            *   如果没有找到足够的邻居用户 (例如，由于 `MIN_COMMON_RATINGS` 过滤掉了大部分用户)，则User-CF算法可能无法提供推荐。
        4.  **获取目标用户已评分电影:**
            *   调用 `db_manager.get_movies_rated_by_user(target_user_id)` 获取目标用户已经评分过的电影ID列表，用于在后续步骤中排除这些电影，避免重复推荐。
        5.  **生成候选电影并预测评分:**
            *   初始化一个空字典 `candidate_movies` 用于存储可能推荐给目标用户的电影及其预测信息。
            *   遍历每一个选出的邻居用户 `neighbor_id` 及其对应的相似度数据 `user_data`：
                *   获取邻居的评分记录 `neighbor_ratings = user_data['ratings']` 和相似度 `similarity = user_data['similarity']`。
                *   遍历该邻居评分过的每一部电影 `movie_id` 及其评分 `score`：
                    *   **排除已看电影:** 如果 `movie_id` 在目标用户已评分的电影列表中，则跳过。
                    *   **考虑高分电影:** 只考虑邻居给予较高评分的电影（例如 `score >= 7`，这个阈值可以调整），认为这些是邻居真正喜欢的电影。
                    *   **累积加权评分:** 对于通过筛选的 `movie_id`，更新 `candidate_movies`：
                        *   如果 `movie_id` 首次出现在 `candidate_movies` 中，则初始化其记录：
                            `candidate_movies[movie_id]['weighted_sum'] = score * similarity` (邻居评分乘以与目标用户的相似度)
                            `candidate_movies[movie_id]['similarity_sum'] = similarity` (累加相似度，用于后续归一化)
                        *   如果 `movie_id` 已存在，则累加：
                            `candidate_movies[movie_id]['weighted_sum'] += score * similarity`
                            `candidate_movies[movie_id]['similarity_sum'] += similarity`
        6.  **计算最终预测评分并排序:**
            *   遍历 `candidate_movies` 中的每一部电影。
            *   计算其最终预测评分 (加权平均): `predicted_score = candidate_movies[movie_id]['weighted_sum'] / candidate_movies[movie_id]['similarity_sum']`。
            *   根据 `predicted_score` 对所有候选电影进行降序排序。
        7.  **返回结果:** 提取排序后得分最高的 `num_recommendations` 部电影的ID列表。
    *   **Content-Based (`get_content_based_recommendations`，主要用于冷启动/补充):**
        1.  **获取用户已评分电影:** 调用 `db_manager.get_movies_rated_by_user(target_user_id)`。
        2.  **获取候选高分电影:** 调用 `db_manager.get_movies_for_content_based_recommendation(exclude_movie_ids=rated_movie_ids, limit=100)`。此函数会从数据库中查询豆瓣评分较高 (`ORDER BY douban_rating DESC`) 的电影，同时排除用户已评分的电影，并限制返回数量（例如100部）作为候选池。
        3.  **增加多样性的随机选择:**
            *   如果候选电影数量不足 `num_recommendations`，则直接返回所有候选电影的ID。
            *   否则，将候选电影按豆瓣评分降序排序。
            *   为了避免总是推荐评分最高的几部电影导致结果单一，系统会从这些高分电影的**前50%**中，使用 `random.sample()` 随机选取 `num_recommendations` 部进行推荐。
    *   **混合推荐 (`generate_recommendations`):**
        1.  **优先User-CF:** 首先调用 `get_user_cf_recommendations`。
        2.  **检查结果数量:** 如果User-CF返回的推荐数量 `>= num_recommendations`，则直接使用这些结果。
        3.  **Content-Based补充:** 如果User-CF结果不足，计算还需要的数量 `needed_count`，然后调用 `get_content_based_recommendations` 获取补充的电影。
        4.  **合并与去重:** 将User-CF和Content-Based的结果合并，确保电影ID不重复，并最终截取到 `num_recommendations` 数量。
        5.  **异常处理与回退:** 整个过程使用 `try-except` 包裹。如果推荐生成过程中出现任何异常，会记录错误日志，并尝试回退到完全使用 `get_content_based_recommendations` 作为备选方案，以保证用户尽可能获得推荐。如果备选方案也失败，则返回空列表。
*   **关键代码片段与公式:**
    *   **User-CF 相似度:** `similarity = 1 / (1 + (Σ(score_target_i - score_other_i)^2 / num_common_movies))`
    *   **User-CF 预测评分:** `predicted_score = Σ(neighbor_score_j * similarity_j) / Σ(similarity_j)`
    ```python
    # User-CF 核心相似度计算示意
    # common_movies = set(target_ratings.keys()) & set(other_ratings.keys())
    # if len(common_movies) < MIN_COMMON_RATINGS: continue
    # sum_sq_diff = sum((target_ratings[m] - other_ratings[m])**2 for m in common_movies)
    # area = sum_sq_diff / len(common_movies)
    # similarity = 1 / (1 + area)

    # Content-Based 随机选择示意
    # sorted_movies = sorted(candidate_movies, key=lambda x: float(x['douban_rating']), reverse=True)
    # top_half = sorted_movies[:len(sorted_movies) // 2]
    # recommended_movies = random.sample(top_half, num_recommendations) # if len(top_half) > num_recommendations

    # generate_recommendations 混合逻辑示意
    # cf_recs = get_user_cf_recommendations(...)
    # if len(cf_recs) >= num_recommendations:
    #     return cf_recs
    # needed = num_recommendations - len(cf_recs)
    # content_recs = get_content_based_recommendations(..., needed)
    # final_recs = cf_recs + [m for m in content_recs if m not in cf_recs]
    # return final_recs[:num_recommendations]
    ```
*   **交互与依赖:**
    *   依赖 `logging`, `random`, `math` 标准库。
    *   依赖 `app.db_manager` 获取所有用户评分数据、用户已评分电影列表、高分电影候选等。
    *   依赖 `app.config` 获取推荐算法参数如 `SIMILAR_USERS_COUNT`, `MIN_COMMON_RATINGS`。
    *   被 `app.wechat_handler` 中的 `handle_movie_recommendation` 函数调用。

#### 2.2.6 `app/utils.py` - 工具模块

*   **功能:** 存放项目中可能共用的辅助函数，例如日期处理、特殊字符串操作、自定义的日志格式化工具等，以提高代码的复用性和模块化程度。
*   **现状:** 当前此模块在项目中为预留状态，并未包含具体的实用功能代码。其内容主要是一些注释，说明了该模块的用途和未来可能添加的函数类型。
*   **未来扩展:** 根据项目后续开发和优化的需要，可以向此模块中添加：
    *   **日志记录工具:** 例如，封装更复杂的日志格式化逻辑，或特定事件的专用日志记录函数。
    *   **数据清洗函数:** 对于用户输入或从外部获取的数据，可能需要标准化的清洗流程。
    *   **通用文本处理:** 例如，更复杂的文本截断逻辑、敏感词过滤等（尽管本项目中微信消息长度控制主要在`db_manager`中）。
    *   **日期时间辅助函数:** 如果项目中需要处理更复杂的日期时间转换或计算。

#### 2.2.7 `app/__init__.py` - 包初始化文件

*   **功能:**
    1.  **声明包:** 此文件的存在使得 `app` 目录被Python解释器视为一个包（package）。这允许我们使用点分路径（如 `from app.config import ...` 或 `from .db_manager import ...`）来导入`app`目录下的其他模块或子包。
    2.  **包级别初始化 (可选):** 可以在此文件中执行当 `app` 包首次被导入时需要运行的代码。例如，设置包级别的配置、注册插件等。本项目当前版本中，此文件主要起声明包的作用，未包含复杂的初始化逻辑。
*   **内容:** 主要包含文件顶部的署名注释和对包结构的注释说明。没有实际的执行代码。
    ```python
    # Mindsnap团队的电影推荐系统分团队 
    # 应用程序包初始化文件

    ############################################################
    # 包初始化说明
    ############################################################
    # 此文件定义了app目录作为Python包，使得其中的模块可以被导入
    # 当导入 'from app import xxx' 时，Python会首先执行此文件

    # (包结构说明注释...)
    ```
*   **重要性:** 如果没有 `__init__.py` 文件，`app` 目录只是一个普通的文件夹，其中的 `.py` 文件不能作为包内模块被方便地导入。

### 2.3 数据库设计
*   **数据库名:** `movie_recommendation_system`
*   **字符集:** `utf8mb4` (支持emoji等特殊字符，对于存储电影标题、简介以及用户昵称等非常重要)。
*   **存储引擎:** 默认为 `InnoDB` (在 `CREATE TABLE` 语句末尾指定)，支持事务和外键约束。
*   **表结构 (SQL DDL 见附录 A.1):**

    1.  **`movies` (电影信息表):** 存储电影的基本属性。
        *   `id` INT AUTO_INCREMENT PRIMARY KEY: 电影唯一标识，自增主键。
        *   `title` VARCHAR(255) NOT NULL: 电影名称。
        *   `douban_rating` DECIMAL(3,1): 豆瓣评分，允许一位小数 (如 9.7)。
        *   `rating_count` INT: 豆瓣上的评价人数，可用于衡量电影热度。
        *   `release_date` VARCHAR(100): 上映日期或年代。使用VARCHAR以适应多种格式 (如 "1994", "2023-10-01")。
        *   `actors` TEXT: 演员列表，多个演员用逗号分隔。
        *   `directors` TEXT: 导演列表，多个导演用逗号分隔。
        *   `genres` VARCHAR(255): 电影类型，多个类型用逗号分隔 (如 "剧情,犯罪")。
        *   `plot_summary` TEXT: 剧情简介。
        *   `poster_url` VARCHAR(512): 海报图片URL (可选功能，当前未使用)。
        *   `douban_url` VARCHAR(512): 豆瓣电影链接 (可选功能，当前未使用)。
        *   `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP: 记录创建时间。
        *   `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP: 记录最后更新时间。
        *   **索引:** 
            *   `idx_movies_title` (`title`): 加速按标题搜索。
            *   `idx_movies_genres` (`genres`): 未来若按类型搜索，可加速。
            *   `idx_movies_douban_rating` (`douban_rating`): 加速按评分排序或筛选。

    2.  **`users` (用户信息表):** 存储微信用户的基本信息。
        *   `id` INT AUTO_INCREMENT PRIMARY KEY: 用户唯一标识，自增主键。
        *   `openid` VARCHAR(128) NOT NULL UNIQUE: 微信用户的OpenID，是识别用户的关键字段，具有唯一性约束。
        *   `nickname` VARCHAR(255): 微信昵称 (可选, 注意隐私政策，本项目暂未主动获取和使用)。
        *   `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP: 用户记录创建时间（通常是首次关注时间）。
        *   `last_active_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP: 用户最后活跃时间，每次用户信息更新时自动刷新（例如，将来可以设计成用户每次发消息都更新此时间戳）。

    3.  **`ratings` (用户评分表):** 存储用户对电影的评分数据，是协同过滤的核心。
        *   `id` INT AUTO_INCREMENT PRIMARY KEY: 评分记录的唯一标识。
        *   `user_id` INT NOT NULL: 关联 `users` 表的 `id`，表示评分者。
        *   `movie_id` INT NOT NULL: 关联 `movies` 表的 `id`，表示被评分的电影。
        *   `score` DECIMAL(3,1) NOT NULL: 用户评分 (0-10分)。
        *   `rated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP: 评分时间，当用户修改评分时此时间戳会自动更新。
        *   **约束与外键:**
            *   `UNIQUE KEY uniq_user_movie_rating (user_id, movie_id)`: 确保一个用户对一部电影只能有一条评分记录。
            *   `FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE`: 当 `users` 表中的用户被删除或其ID更新时，相关的评分记录也会被级联删除或更新其 `user_id`。
            *   `FOREIGN KEY (movie_id) REFERENCES movies(id) ON DELETE CASCADE ON UPDATE CASCADE`: 同理，关联到 `movies` 表。
        *   **索引:** 
            *   `idx_ratings_user_id` (`user_id`): 加速查询特定用户的所有评分。
            *   `idx_ratings_movie_id` (`movie_id`): 加速查询特定电影的所有评分。

    4.  **`search_logs` (用户搜索记录表 - 可选实现):** 存储用户的搜索历史。
        *   `id` INT AUTO_INCREMENT PRIMARY KEY: 记录唯一标识。
        *   `user_id` INT NOT NULL: 关联 `users` 表的 `id`。
        *   `search_query` VARCHAR(255) NOT NULL: 用户输入的搜索关键词。
        *   `search_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP: 搜索发生的时间。
        *   **外键:** `FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE`.
        *   **索引:** 
            *   `idx_search_logs_user_id` (`user_id`): 加速查询特定用户的搜索历史。
            *   `idx_search_logs_query` (`search_query`): 未来若分析热门搜索词，可加速。

### 2.4 接口设计 (微信公众号 -> 后端)
后端应用通过根路径 `/` 接收并处理来自微信服务器的所有HTTP请求。

1.  **GET请求 (服务器验证接口):**
    *   **路径:** `/`
    *   **方法:** `GET`
    *   **处理模块:** `app/main.py` -> `WeChatInterface.GET()`
    *   **接收参数 (Query Parameters):**
        *   `signature`: 微信加密签名。
        *   `timestamp`: 时间戳。
        *   `nonce`: 随机数。
        *   `echostr`: 随机字符串（验证成功后原样返回）。
    *   **核心逻辑 (`app/wechat_handler.check_signature`):**
        1.  将 `WECHAT_TOKEN` (来自`app/config.py`)、`timestamp`、`nonce` 三个参数进行字典序排序。
        2.  将三个参数字符串拼接成一个字符串。
        3.  对拼接后的字符串进行SHA1哈希加密。
        4.  将加密后的字符串与微信传递的 `signature` 进行对比。
        5.  如果一致，验证成功，`WeChatInterface.GET()` 方法返回 `echostr`。
        6.  如果不一致，验证失败，返回错误提示。
    *   **目的:** 用于在微信公众号后台配置服务器URL时，验证后端服务的有效性和Token的正确性。

2.  **POST请求 (消息与事件接收接口):**
    *   **路径:** `/`
    *   **方法:** `POST`
    *   **处理模块:** `app/main.py` -> `WeChatInterface.POST()` -> `app/wechat_handler.handle_wechat_message()`
    *   **请求体 (Request Body):** XML格式的数据，包含微信用户发送给公众号的各类消息或公众号发生的事件。关键字段包括：
        *   `ToUserName`: 开发者微信号 (公众号原始ID)。
        *   `FromUserName`: 发送方帐号 (一个OpenID，即用户的唯一标识)。
        *   `CreateTime`: 消息创建时间 (整型)。
        *   `MsgType`: 消息类型 (如 `text`, `image`, `event` 等)。
        *   `Content` (当 `MsgType` 为 `text` 时): 文本消息内容。
        *   `Event` (当 `MsgType` 为 `event` 时): 事件类型 (如 `subscribe`, `unsubscribe`, `CLICK` 等)。
        *   `EventKey` (当某些事件类型时): 事件KEY值，与自定义菜单接口中KEY值对应。
    *   **响应体 (Response Body):** XML格式数据，用于被动回复用户消息。结构与请求类似，但通常只包含 `ToUserName`, `FromUserName`, `CreateTime`, `MsgType`, 和对应消息类型的内容字段 (如 `Content` for text)。
    *   **核心处理逻辑 (`app/wechat_handler.handle_wechat_message`):** 详细解析见 2.2.3 节。主要根据 `MsgType` 和 `Content` (或 `Event`) 分发到不同的处理函数：
        *   **文本消息 (`MsgType == "text"`):**
            *   `Content == "推荐"`: 调用 `handle_movie_recommendation()`。
            *   `Content` 以 "评价 " 开头: 调用 `handle_movie_rating()`。
            *   其他文本: 调用 `handle_movie_search()`。
        *   **事件消息 (`MsgType == "event"`):**
            *   `Event == "subscribe"` (关注事件): 创建/获取用户信息，回复欢迎语。
            *   `Event == "unsubscribe"` (取消关注事件): 记录日志，不回复。
    *   **目的:** 作为系统与用户交互的主要通道，接收用户指令，处理业务逻辑，并返回结果。

## 3. 核心功能实现详解

本节将详细阐述系统核心功能的实现逻辑，并关联到具体的代码模块和函数，展示它们如何协同工作以响应用户通过微信公众号发出的指令。

### 3.1 用户关注与欢迎 (`app.wechat_handler.handle_wechat_message` 处理 `subscribe` 事件)
*   **用户操作:** 用户在微信中搜索并关注本电影推荐公众号。
*   **触发流程:**
    1.  微信服务器检测到用户的关注行为，向后端配置的URL (即本应用的 `/` 路径) 发送一个`POST`请求，消息类型 `MsgType` 为 `event`，事件类型 `Event` 为 `subscribe`。
    2.  `app/main.py` 中的 `WeChatInterface.POST()` 方法接收到此请求，并将原始XML数据传递给 `app.wechat_handler.handle_wechat_message()` 函数。
*   **核心处理逻辑 (`app.wechat_handler.handle_wechat_message`内部):**
    1.  函数解析XML数据，识别出 `MsgType='event'` 和 `Event='subscribe'`。
    2.  从XML中提取 `FromUserName` (用户的OpenID) 和 `ToUserName` (公众号的原始ID)。
    3.  **用户入库/激活:** 调用 `app.db_manager.get_user_id_by_openid(from_user_openid)`。
        *   此函数首先会尝试使用 `get_user_by_openid` 根据 `from_user_openid` 在 `users` 表中查找用户。
        *   如果用户不存在（即首次关注），则调用 `create_user(from_user_openid)` 在 `users` 表中创建一条新记录，存储用户的OpenID，并返回新生成的 `user_id`。
        *   如果用户已存在（例如之前取关后重新关注），则直接返回其已有的 `user_id`，并可能更新其 `last_active_at` 时间戳（取决于具体实现）。
    4.  **构建欢迎消息:** 定义一段固定的欢迎文本，通常包含系统名称、主要功能介绍以及如何使用各项功能的简要说明 (如搜索指令、评价指令、推荐指令)。
        ```python
        # 示例欢迎语 (在 wechat_handler.py 中)
        welcome_msg = (
            "欢迎使用个性化电影推荐！\n\n"
            "您可以：\n"
            "1. 输入电影名搜索，如：泰坦尼克号\n"
            "2. 评价电影，如：评价 泰坦尼克号 9\n"
            "3. 获取推荐，输入：推荐"
        )
        ```
    5.  **回复用户:** 调用 `app.wechat_handler.build_text_response(to_user_for_reply, from_user_for_reply, welcome_msg)` 构建标准格式的微信文本回复XML。
        *   注意此时 `to_user_for_reply` 应该是原始请求中的 `FromUserName` (用户OpenID)，而 `from_user_for_reply` 应该是原始请求中的 `ToUserName` (公众号原始ID)，因为是公众号回复给用户。
*   **最终效果:** 用户关注公众号后，会立即收到一条包含欢迎语和使用指南的文本消息。

### 3.2 电影搜索 (`app.wechat_handler.handle_movie_search`)
*   **用户操作:** 用户在公众号对话框中直接输入电影名称或关键词 (如 "阿甘正传", "黑客帝国")。
*   **触发流程:**
    1.  用户发送的文本消息被微信服务器转发到后端 `/` 路径的 `POST` 请求，`MsgType` 为 `text`。
    2.  `app/main.py` 的 `WeChatInterface.POST()` 将XML数据传递给 `app.wechat_handler.handle_wechat_message()`。
    3.  `handle_wechat_message` 解析后，如果文本内容不是特定的指令 (如 "推荐" 或以 "评价 " 开头)，则将其分发给 `app.wechat_handler.handle_movie_search(from_user_openid, content)`。
*   **核心处理逻辑 (`app.wechat_handler.handle_movie_search` 内部):**
    1.  **输入处理:** 获取 `from_user_openid` 和用户输入的电影标题 `movie_title`。对 `movie_title` 进行清理 (例如 `strip()` 去除首尾空格)。
    2.  **用户识别与日志记录:**
        *   调用 `app.db_manager.get_user_id_by_openid(from_user_openid)` 获取当前用户的 `user_id`。
        *   调用 `app.db_manager.log_search_query(user_id, cleaned_movie_title)` 将用户的此次搜索行为记录到 `search_logs` 表中。
    3.  **执行搜索:**
        *   **精确搜索优先:** 调用 `app.db_manager.search_movies_by_title_exact(cleaned_movie_title)` 尝试精确匹配电影标题。
        *   **模糊搜索补充:** 如果精确搜索没有结果 (`not exact_movies`)，则调用 `app.db_manager.search_movies_by_title_fuzzy(cleaned_movie_title, limit=MAX_SEARCH_RESULTS * 2)` 进行模糊搜索。模糊搜索会多获取一些结果 (例如配置中 `MAX_SEARCH_RESULTS` 的两倍)，以便后续格式化时有更多选择，并按豆瓣评分降序排列。
    4.  **结果格式化与回复:**
        *   **判断是否有结果:** 如果精确搜索和模糊搜索都没有找到任何电影，则构建提示信息如 "抱歉，未找到与《{电影名}》相关的电影。请换个关键词试试吧！"
        *   **格式化展示:** 如果有搜索结果 (无论是精确的还是模糊的)，则调用 `app.db_manager.get_movie_details_for_display(movies_found, max_movies_to_display=MAX_SEARCH_RESULTS)`。
            *   此函数负责将电影数据（标题、评分、年代、简介等）整理成对用户友好的文本格式。
            *   它会智能截断过长的简介，控制单条消息中展示的电影数量 (`MAX_SEARCH_RESULTS` 来自 `app.config`)，并确保回复的总字符数不超过微信的限制，避免消息被截断或发送失败。
            *   如果模糊搜索返回的结果较多，函数可能会在末尾追加提示，如 "模糊搜索到多个结果，已显示评分较高的前N部。"
        *   调用 `app.wechat_handler.build_text_response()` 将格式化后的电影信息或提示信息包装成XML回复给用户。
*   **最终效果:** 用户输入电影名后，会收到包含匹配电影信息的文本消息，或者未找到电影的提示。

### 3.3 电影评分 (`app.wechat_handler.handle_movie_rating`)
*   **用户操作:** 用户发送特定格式的评分指令 (如 "评价 肖申克的救赎 9.5" 或 "评价 阿甘 8")。
*   **触发流程:**
    1.  用户发送的评分指令作为文本消息被微信服务器转发。
    2.  `app/main.py` 和 `app.wechat_handler.handle_wechat_message` 按常规文本消息处理。
    3.  `handle_wechat_message` 检测到消息内容以 "评价 " 开头，遂将其分发给 `app.wechat_handler.handle_movie_rating(from_user_openid, content)`。
*   **核心处理逻辑 (`app.wechat_handler.handle_movie_rating` 内部):**
    1.  **指令解析:** 使用正则表达式 `r'^评价\\s+(.+)\\s+(\\d+(\\.\\d)?)$'` 从用户输入的 `content` 中提取电影名称 (`movie_name`) 和评分值 (`score_str`)。
        *   如果格式不匹配 (例如，缺少电影名、缺少评分、或评分格式不正确)，则返回格式错误提示，如 "评价格式不正确，请使用：评价 电影名 评分 (0-10)"。
    2.  **评分值校验与转换:**
        *   将提取的 `score_str` 转换为浮点数 `score`。
        *   检查 `score` 是否在0到10的有效范围内。如果小于0，则修正为0；如果大于10，则修正为10。并在后续的回复中向用户说明评分已被调整。
    3.  **用户与电影识别:**
        *   调用 `app.db_manager.get_user_id_by_openid(from_user_openid)` 获取当前用户的 `user_id`。
        *   调用 `app.db_manager.search_movies_by_title_exact(movie_name)` 根据提取的电影名称精确查找电影。
            *   如果未找到该电影，返回提示如 "未找到电影《{电影名}》，无法评价。"
            *   **同名电影处理:** 如果找到多部同名电影，当前实现是默认选择第一部 (`found_movies[0]`) 进行评价，并在回复中提示用户 "找到多部名为《{电影名}》的电影，已为您评价第一部。如有歧义，请使用更精确的名称。" 这是一个简化的处理方式，未来可以优化为让用户选择。
    4.  **存储评分:** 获取到 `user_id` 和唯一的 `movie_id` 后，调用 `app.db_manager.add_or_update_rating(user_id, movie_id, score)`。
        *   此函数会自动判断是新增评分还是更新用户对该电影已有的评分，并将评分数据写入 `ratings` 表。
    5.  **构建回复:** 根据操作结果（成功、失败、评分调整等）构建相应的文本回复。
        *   成功示例: "《{电影名}》评分 {评分} 成功！"
        *   评分调整示例: "《{电影名}》评分 {原始评分} 已调整为 {调整后评分} 并记录成功！(评分范围0-10)"
    6.  调用 `app.wechat_handler.build_text_response()` 将回复包装成XML。
*   **最终效果:** 用户发送评分指令后，系统会记录其评分，并向用户反馈操作结果。

### 3.4 个性化推荐 (`app.wechat_handler.handle_movie_recommendation`)
*   **用户操作:** 用户在公众号对话框中发送文本 "推荐"。
*   **触发流程:**
    1.  "推荐" 指令作为文本消息被微信服务器转发。
    2.  `app/main.py` 和 `app.wechat_handler.handle_wechat_message` 按常规文本消息处理。
    3.  `handle_wechat_message` 检测到消息内容为 "推荐"，将其分发给 `app.wechat_handler.handle_movie_recommendation(from_user_openid)`。
*   **核心处理逻辑 (`app.wechat_handler.handle_movie_recommendation` 内部):**
    1.  **用户识别:** 调用 `app.db_manager.get_user_id_by_openid(from_user_openid)` 获取当前用户的 `user_id`。
    2.  **用户评分数据检查 (预处理):**
        *   调用 `app.db_manager.get_user_ratings(user_id)` 获取该用户的所有评分记录。
        *   统计评分数量 `ratings_count`。
        *   **冷启动判断:** 如果 `ratings_count == 0` (用户从未评过分)，则直接返回提示信息，如 "您目前还没有评价过任何电影，评价几部您看过的电影后，我才能更懂您的口味哦！请尝试发送：评价 电影名 分数"，不进行后续推荐流程。
        *   **评分不足提示:** 如果 `ratings_count` 大于0但小于某个阈值 (例如3部，这个阈值可以在 `app.config.py` 中配置为 `MIN_RATINGS_FOR_GOOD_RECOMMENDATION`)，则在最终的推荐结果前附加一条提示，如 "您的评分数据还比较少，本次推荐可能不完全符合您的口味，评价越多，推荐越准哦！"
    3.  **调用推荐引擎:**
        *   调用 `app.recommendation_engine.generate_recommendations(user_id, DEFAULT_RECOMMENDATIONS_COUNT)`。
        *   `DEFAULT_RECOMMENDATIONS_COUNT` 来自 `app.config.py`，定义了单次推荐的电影数量 (例如3或5部)。
        *   此函数内部会执行混合推荐策略：优先尝试基于用户的协同过滤 (User-CF)，如果结果不足，则使用基于内容的推荐 (Content-Based) 进行补充，并处理异常回退 (详见 2.2.5 节和第4节推荐算法详解)。
    4.  **处理与格式化推荐结果:**
        *   **无推荐结果:** 如果 `generate_recommendations` 返回空列表 (可能因为用户数据极其稀疏或算法未能找到合适的推荐)，则返回提示信息，如 "很抱歉，系统暂时无法为您生成个性化推荐。请尝试评价更多不同类型的电影，或稍后再试。"
        *   **获取电影详情:** 如果推荐引擎返回了电影ID列表 `recommended_movie_ids`，则遍历此列表，对每个 `movie_id` 调用 `app.db_manager.get_movie_by_id(movie_id)` 从 `movies` 表中获取完整的电影信息。
        *   **格式化展示:** 将获取到的电影信息对象列表传递给 `app.db_manager.get_movie_details_for_display(movies_info_list, max_movies_to_display=DEFAULT_RECOMMENDATIONS_COUNT)`。
            *   此函数会将推荐的电影信息格式化为用户友好的文本，处理逻辑与电影搜索结果的格式化类似，包括简介截断和总长度控制。
        *   在格式化的电影列表前，根据之前的评分数量判断，选择性地添加上述的"评分不足提示"。
    5.  调用 `app.wechat_handler.build_text_response()` 将最终的推荐结果（或提示信息）包装成XML回复给用户。
*   **最终效果:** 用户发送 "推荐" 指令后，会收到一个包含数部个性化推荐电影信息的列表，或者在特定情况下收到相应的提示。

## 4. 推荐算法详解

本系统的核心推荐逻辑由 `app/recommendation_engine.py` 模块实现，主要包含基于用户的协同过滤（User-CF）、基于内容的推荐以及将两者结合的混合推荐策略。

### 4.1 基于用户的协同过滤 (User-CF)

User-CF算法的核心思想是"人以群分"，即找到与目标用户品味相似的用户群体（邻居），然后将这些邻居喜欢且目标用户尚未接触过的物品推荐给目标用户。此算法在 `get_user_cf_recommendations(target_user_id, num_recommendations)` 函数中实现。

1.  **数据准备与转换:**
    *   **目标用户数据:** 调用 `db_manager.get_user_ratings(target_user_id)` 获取目标用户的评分记录，格式为 `[{'movie_id': mid, 'score': s}, ...]`。
    *   **全体用户数据:** 调用 `db_manager.get_all_user_ratings()` 获取所有用户的评分数据，格式为 `{uid1: [{'movie_id': mid, 'score': s}, ...], uid2: [...], ...}`。
    *   **数据结构转换:** 为了便于计算，目标用户和其他用户的评分记录都转换为字典形式，键为 `movie_id`，值为 `score`，如 `target_ratings_dict = {movie_id: score}`。

2.  **用户相似度计算:**
    *   遍历 `all_user_ratings` 中的每一个其他用户 `other_user_id`。
    *   **共同评分电影:** 找出目标用户和 `other_user_id` 都评分过的电影集合 `common_movies` (通过Python集合的交集操作 `set(target_ratings_dict.keys()) & set(other_user_ratings_dict.keys())`)。
    *   **最小共同评分数过滤:** 如果共同评分的电影数量 `len(common_movies)` 小于配置文件 `app/config.py` 中定义的 `MIN_COMMON_RATINGS` (例如，2部)，则认为这两个用户的共同基础太少，相似度计算不可靠，跳过此 `other_user_id`。
    *   **相似度计算公式 (源自论文思路，基于评分差平方):**
        *   计算评分差的平方和: `sum_squared_diff = Σ (target_ratings_dict[movie_id] - other_user_ratings_dict[movie_id]) ** 2`，其中求和针对所有 `common_movies`。
        *   计算平均差异值: `area = sum_squared_diff / len(common_movies)`。这个 `area` 值越小，表示两个用户对共同电影的评分差异越小，即越相似。
        *   将差异值转换为相似度: `similarity = 1 / (1 + area)`。此公式使得相似度值域为 (0, 1]，值越大表示越相似。若评分完全一致，`area = 0`, `similarity = 1`。
    *   存储计算得到的相似度信息: `user_similarity[other_user_id] = {'similarity': similarity, 'common_movies': len(common_movies), 'ratings': other_user_ratings_dict}`。

3.  **选取Top-N邻居:**
    *   将 `user_similarity` 字典按 `similarity` 值进行降序排序。
    *   选取排序后的前 `SIMILAR_USERS_COUNT` (来自 `app/config.py`，例如10) 个用户作为目标用户的"邻居"。

4.  **生成候选电影与预测评分:**
    *   **排除已看电影:** 调用 `db_manager.get_movies_rated_by_user(target_user_id)` 获取目标用户已评分的电影ID列表 `rated_movie_ids`，这些电影将不会被推荐。
    *   **遍历邻居贡献:** 初始化一个空字典 `candidate_movies` 用于存储候选电影的加权评分和总相似度。
        *   对于每个邻居及其与目标用户的相似度 `similarity`：
            *   遍历该邻居评分过的所有电影 `movie_id` 及其评分 `score`。
            *   **过滤条件:**
                1.  电影 `movie_id` 不能在 `rated_movie_ids` 中 (目标用户未看过)。
                2.  邻居对该电影的评分必须较高 (当前实现中硬编码为 `score >= 7`)，表明这是邻居真正喜欢的电影。
            *   **累积加权评分:** 对于通过筛选的 `movie_id`：
                *   `candidate_movies[movie_id]['weighted_sum'] += score * similarity`
                *   `candidate_movies[movie_id]['similarity_sum'] += similarity`

5.  **最终推荐列表:**
    *   **计算预测评分:** 对于 `candidate_movies` 中的每一部电影，其最终预测评分 `predicted_score = candidate_movies[movie_id]['weighted_sum'] / candidate_movies[movie_id]['similarity_sum']`。
    *   **排序与截取:** 根据 `predicted_score` 对所有候选电影进行降序排序。
    *   返回得分最高的 `num_recommendations` 部电影的ID列表。

### 4.2 基于内容的推荐 (Content-Based)

基于内容的推荐主要用于解决冷启动问题（新用户或评分数据少的用户）以及作为User-CF结果不足时的补充。此算法在 `get_content_based_recommendations(target_user_id, num_recommendations)` 函数中实现。

1.  **数据准备:**
    *   **获取用户已评分电影:** 调用 `db_manager.get_movies_rated_by_user(target_user_id)` 获取 `rated_movie_ids`，以便排除。
    *   **获取候选高分电影:** 调用 `db_manager.get_movies_for_content_based_recommendation(exclude_movie_ids=rated_movie_ids, limit=100)`。此函数会：
        *   从 `movies` 表中选取电影。
        *   排除 `rated_movie_ids` 中的电影。
        *   按 `douban_rating` 降序排列。
        *   返回评分较高且用户未看过的电影列表作为候选池 (例如前100部)。

2.  **增加多样性的随机选择:**
    *   如果候选电影数量不足 `num_recommendations`，则直接返回所有候选电影的ID。
    *   否则，为了避免总是推荐少数几部评分最高的电影而导致结果单一：
        1.  将候选电影池按豆瓣评分 `douban_rating` 进行降序排序。
        2.  仅考虑这个排序后列表的**前半部分** (即 `top_half = sorted_movies[:len(sorted_movies) // 2]`)。
        3.  从 `top_half` 中使用 `random.sample()` 随机选取 `num_recommendations` 部电影的ID进行推荐。
    *   这种策略在保证推荐质量（来自高分电影）的同时，引入了一定的随机性，有助于提升推荐结果的多样性和新颖性。

3.  **应用场景:**
    *   **新用户冷启动:** 当用户没有任何评分数据时，User-CF无法工作，此时主要依赖此算法。
    *   **评分稀疏用户:** 用户评分较少，难以找到足够数量的相似邻居。
    *   **User-CF补充:** 当User-CF生成的推荐数量不足时，用于补齐推荐列表。

### 4.3 混合推荐策略

系统的最终推荐结果由 `generate_recommendations(target_user_id, num_recommendations)` 函数生成，它采用了一种混合策略：

1.  **优先User-CF:** 首先尝试调用 `get_user_cf_recommendations` 获取基于协同过滤的推荐列表 `cf_recs`。
2.  **检查结果数量:**
    *   如果 `len(cf_recs)` 已经达到或超过了期望的 `num_recommendations` (来自 `app.config.DEFAULT_RECOMMENDATIONS_COUNT`)，则直接截取并返回这些结果。
3.  **Content-Based补充:**
    *   如果User-CF的结果数量不足 (`len(cf_recs) < num_recommendations`)，计算还需要的推荐数量 `needed_count = num_recommendations - len(cf_recs)`。
    *   调用 `get_content_based_recommendations(target_user_id, needed_count)` 获取基于内容的推荐列表 `content_recs` 来补充。
4.  **合并与去重:**
    *   将 `cf_recs` 和 `content_recs` 合并。
    *   确保最终推荐列表中的电影ID不重复 (例如，内容推荐的结果可能与少量CF结果重合)。
    *   截取最终列表至 `num_recommendations` 数量。
5.  **异常处理与回退:**
    *   整个推荐生成过程被包裹在 `try-except` 块中。
    *   如果在尝试User-CF或混合策略时发生任何异常，系统会记录错误日志，并**回退到完全使用基于内容的推荐** (`get_content_based_recommendations(target_user_id, num_recommendations)`) 作为备选方案。
    *   如果备选方案也失败（例如数据库访问异常），则返回一个空列表，并在上层逻辑 (`wechat_handler`) 中向用户给出相应提示。

这种混合策略旨在结合不同算法的优点，提高推荐的准确性和覆盖率，同时保证系统的健壮性。

## 5. 系统部署

本节详细介绍如何在阿里云Ubuntu服务器上部署此电影推荐系统。系统提供了自动部署脚本 (`deploy.sh`) 以简化流程，同时也提供了手动部署步骤和用于服务管理的启停脚本。

### 5.1 部署准备工作

在开始部署之前，请确保以下条件已满足：

1.  **服务器环境:** 一台已配置好基本环境的阿里云ECS实例（Ubuntu 20.04 LTS或更高版本），具有公网IP地址，并且已安装Python 3.9+、pip、git和venv。
2.  **安全组配置:**
    *   开放TCP端口 `22` (用于SSH远程登录)。
    *   开放TCP端口 `80` (用于微信公众号HTTP接入；如果使用Nginx反向代理，则可能是Nginx监听的端口)。
    *   如果MySQL数据库也部署在此服务器上，并且需要从外部（例如本地开发环境）访问，则需开放TCP端口 `3306`。但强烈建议不要将数据库端口直接暴露于公网，应优先考虑通过SSH隧道访问或限制其仅对服务器内部IP可见。
3.  **数据库配置:**
    *   MySQL服务已安装并运行（可以与应用服务器在同一台ECS，或使用阿里云RDS等云数据库服务）。
    *   已创建名为 `movie_recommendation_system` 的数据库。
    *   已创建具有相应权限的数据库用户 (如 `movie_rec_user`)，并记录其密码。
    *   数据库表结构已通过执行附录A.1中的SQL DDL语句创建完毕。
    *   `movies` 表已填充了至少200条测试数据。
4.  **代码获取:** 项目代码已通过 `git clone https://github.com/Boulea7/Movie_recommender_wechat.git` 克隆到服务器的指定目录（例如 `/home/ubuntu/Movie_recommender_wechat`）。
5.  **配置文件核对:** 确保 `app/config.py` 中的 `DB_CONFIG` 指向正确的数据库实例地址、用户和密码。

### 5.2 自动化部署脚本 (`deploy.sh`)

项目根目录下的 `deploy.sh` 脚本旨在自动化大部分部署步骤，减少手动操作的复杂性和出错风险。该脚本主要执行以下操作：

1.  **环境设置与日志:**
    *   定义项目目录、虚拟环境目录、日志文件路径等变量。
    *   设置脚本在执行时同时输出到控制台和指定的日志文件 (`deploy.log`)。
2.  **权限检查:** 检查当前是否以root权限运行（因为监听80端口通常需要root权限，或者需要配置Nginx等反向代理）。如果应用本身监听非特权端口（如8080），此检查可以调整。
3.  **目录切换:** 切换到项目根目录。
4.  **代码更新 (可选):** 脚本中预留了 `git pull` 命令的注释，可以取消注释以在每次部署时自动拉取最新代码。
5.  **Python虚拟环境创建与激活:**
    *   检查指定的生产虚拟环境目录 (`.venv_prod`) 是否存在。如果不存在，则使用 `python3 -m venv .venv_prod` 创建。
    *   激活虚拟环境 (`source .venv_prod/bin/activate`)。
6.  **依赖安装:** 执行 `pip install -r requirements.txt` 安装所有项目依赖到虚拟环境中。
7.  **端口检查与处理 (针对直接监听80端口):**
    *   使用 `sudo lsof -t -i:80 -sTCP:LISTEN` 检查80端口是否已被占用。
    *   如果被占用，会提示用户并询问是否尝试结束占用进程。用户确认后，使用 `sudo kill -9 <PID>` 结束进程。
    *   **注意:** 生产环境更推荐使用Nginx作为反向代理监听80端口，并将请求转发到应用监听的非特权端口 (如8080)。如果采用此方案，`deploy.sh`中此部分逻辑需要相应调整或移除。
8.  **应用启动:**
    *   使用 `nohup .venv_prod/bin/python app/main.py 80 > app.log 2>&1 &` 命令在后台启动web.py应用。 （**重要:** 此处假设 `app/main.py` 已被修改为可以从命令行接收端口号作为参数，并且web.py应用内部使用此参数监听端口）。
    *   `nohup`: 保证即使关闭SSH会话，应用也能持续运行。
    *   `>` `app.log` `2>&1`: 将标准输出和标准错误都重定向到项目根目录下的 `app.log` 文件。
    *   `&`: 使命令在后台执行。
    *   记录启动后的进程PID。
9.  **启动状态检查:** 短暂等待后，通过 `ps -p $APP_PID` 检查应用进程是否成功启动。如果启动失败，会给出错误提示。
10. **完成与退出:** 输出部署完成信息，并停用虚拟环境。

**使用方法:**

```bash
sudo bash deploy.sh
```

**注意事项:**
*   首次运行前，请根据实际服务器路径修改 `deploy.sh` 脚本头部的 `PROJECT_DIR` 变量。
*   确保 `app/main.py` 的启动逻辑与 `deploy.sh` 中的启动命令兼容（特别是端口处理）。如 `app/main.py` 中硬编码监听8080端口，则 `deploy.sh` 中启动命令应为 `... app/main.py 8080 ...`，并且微信公众号后台或Nginx应配置为访问此8080端口。
*   对于生产环境，强烈建议使用Gunicorn或uWSGI配合Nginx来部署Python Web应用，以获得更好的性能、稳定性和安全性。`deploy.sh` 可以进行相应调整以支持这种部署方式。

### 5.3 手动部署步骤 (备选方案)

如果不想使用自动化脚本，或需要更细致地控制部署过程，可以按照以下手动步骤操作：

1.  **SSH登录服务器:** `ssh your_user@your_server_ip`
2.  **进入项目目录:** `cd /path/to/your/Movie_Recommender_WeChat` (替换为实际路径)
3.  **拉取最新代码 (可选):** `git pull origin main`
4.  **创建并激活虚拟环境:**
    ```bash
    python3 -m venv .venv_prod
    source .venv_prod/bin/activate
    ```
5.  **安装依赖:** `pip install -r requirements.txt`
6.  **检查配置文件:** 确保 `app/config.py` 中的数据库连接等信息正确无误。
7.  **启动应用 (示例，监听8080端口):**
    ```bash
    nohup .venv_prod/bin/python app/main.py 8080 > app.log 2>&1 &
    ```
    *   如果需要监听80端口，并且没有使用Nginx等反代，则命令前需要加 `sudo`，且要确保 `app/main.py` 能正确处理监听80端口的逻辑。
    *   可以通过 `tail -f app.log` 查看应用实时日志。

### 5.4 服务管理脚本

为了方便管理后台运行的应用进程，项目提供了基础的启动和停止脚本。

#### 5.4.1 `start.sh` - 启动服务脚本

此脚本通常封装了后台启动应用的命令，类似于 `deploy.sh` 中的启动部分，但可能更简洁，专注于启动。

**示例 `start.sh` 内容:**
```bash
#!/bin/bash

PROJECT_DIR="/path/to/your/Movie_Recommender_WeChat" # 替换为你的项目路径
LOG_FILE="$PROJECT_DIR/app.log"
VENV_PYTHON="$PROJECT_DIR/.venv_prod/bin/python"
MAIN_SCRIPT="$PROJECT_DIR/app/main.py"
PORT=8080 # 应用监听的端口

echo "正在启动 Mindsnap 电影推荐系统..."

cd "$PROJECT_DIR" || exit

# 检查是否已在运行 (基于端口)
if lsof -Pi :"$PORT" -sTCP:LISTEN -t >/dev/null ; then
    echo "错误：端口 $PORT 已被占用。服务可能已在运行。"
    exit 1
fi

# 激活虚拟环境 (如果脚本内需要，或者确保环境已激活)
source "$PROJECT_DIR/.venv_prod/bin/activate" || { echo "激活虚拟环境失败"; exit 1; }

nohup "$VENV_PYTHON" "$MAIN_SCRIPT" "$PORT" > "$LOG_FILE" 2>&1 &

APP_PID=$!
sleep 2

if ps -p $APP_PID > /dev/null; then
    echo "服务已启动，PID: $APP_PID。日志请查看: $LOG_FILE"
else
    echo "错误：服务启动失败。请检查 $LOG_FILE。"
    exit 1
fi

deactivate # 如果在脚本中激活了虚拟环境
```
**使用:** `bash start.sh`

#### 5.4.2 `stop.sh` - 停止服务脚本

此脚本用于查找并结束正在运行的应用进程。

**示例 `stop.sh` 内容:**
```bash
#!/bin/bash

PROJECT_DIR="/path/to/your/Movie_Recommender_WeChat" # 替换为你的项目路径
MAIN_SCRIPT_NAME="app/main.py"
PORT_TO_CHECK=8080 # 应用监听的端口，用于更精确查找

echo "正在停止 Mindsnap 电影推荐系统..."

# 尝试通过监听端口找到PID (更可靠的方式)
APP_PID=$(lsof -ti :"$PORT_TO_CHECK" -sTCP:LISTEN)

if [ -z "$APP_PID" ]; then
    # 如果通过端口未找到，尝试通过脚本名查找 (可能不够精确)
    # 注意：pgrep 的 -f 参数会匹配整个命令行，所以需要确保匹配模式足够独特
    APP_PID=$(pgrep -f "python.*$MAIN_SCRIPT_NAME $PORT_TO_CHECK")
fi

if [ -n "$APP_PID" ]; then
    echo "找到运行中的服务实例 (PID: $APP_PID)，正在尝试终止..."
    kill "$APP_PID"
    sleep 2
    if ps -p "$APP_PID" > /dev/null; then
        echo "服务未能完全终止，尝试强制结束 (kill -9)..."
        kill -9 "$APP_PID"
        sleep 1
    fi
    
    if ! ps -p "$APP_PID" > /dev/null; then
        echo "服务已成功停止。"
    else
        echo "错误：未能停止服务 (PID: $APP_PID)。请手动检查。"
        exit 1
    fi
else
    echo "未找到正在运行的服务实例。"
fi
```
**使用:** `bash stop.sh`

**注意:** `stop.sh` 中查找进程ID (PID) 的方法有多种。通过监听端口 (`lsof`) 通常比通过进程名 (`pgrep`) 更准确，尤其是在可能有多个Python脚本运行时。脚本中提供了两种方式的示例。确保匹配条件足够精确，以避免误杀其他进程。

### 5.5 Nginx反向代理配置 (推荐)

为了提高安全性、性能并方便管理HTTPS，推荐使用Nginx作为反向代理服务器。Nginx将监听公网的80端口（HTTP）和/或443端口（HTTPS），并将请求转发给在本地非特权端口（如8080）上运行的web.py应用。

**示例Nginx配置 (`/etc/nginx/sites-available/movie_recommender`):**

```nginx
server {
    listen 80;
    server_name your_domain_or_server_ip; # 替换为你的域名或服务器IP

    location / {
        proxy_pass http://127.0.0.1:8080; # 假设web.py应用监听8080端口
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    access_log /var/log/nginx/movie_recommender_access.log;
    error_log /var/log/nginx/movie_recommender_error.log;
}
```

**配置步骤:**
1.  创建配置文件: `sudo nano /etc/nginx/sites-available/movie_recommender`
2.  粘贴以上内容，并修改 `server_name` 和 `proxy_pass` 中的端口（如果应用监听的不是8080）。
3.  创建软链接到 `sites-enabled`: `sudo ln -s /etc/nginx/sites-available/movie_recommender /etc/nginx/sites-enabled/`
4.  测试Nginx配置: `sudo nginx -t`
5.  如果测试成功，重载Nginx: `sudo systemctl reload nginx`

如果使用Nginx，微信公众号后台的服务器URL应配置为指向Nginx监听的公网地址（通常是 `http://your_domain_or_server_ip/`），而 `app/main.py` 则应配置为监听本地端口（如8080）。`deploy.sh` 中关于80端口检查和直接启动应用监听80端口的逻辑也需要相应调整。

## 6. 优化与扩展点

系统在设计和实现中已考虑多个优化方向：

1. **推荐算法优化：**
   - 使用MIN_COMMON_RATINGS参数调整相似度计算的可靠性
   - 实现了多样性策略：从高分电影中随机选择，避免推荐结果单一
   - 冷启动问题的处理：针对新用户提供基于内容的推荐

2. **错误处理和容错：**
   - 完善的异常捕获和日志记录
   - 推荐失败时的备选策略
   - 评分范围自动调整

3. **潜在扩展方向：**
   - 实现基于物品的协同过滤(Item-CF)
   - 添加更复杂的推荐算法（如矩阵分解）
   - 开发管理员界面
   - 电影数据自动更新机制
   - 推荐结果多样性进一步优化

## 7. 总结

本项目实现了一个功能完整的个性化电影推荐系统，通过微信公众号为用户提供直观的交互方式。系统核心功能包括电影搜索、评分和个性化推荐，重点解决了推荐系统中的冷启动问题和数据稀疏性问题。

推荐算法采用了基于用户的协同过滤作为主要策略，辅以基于内容的推荐算法，实现了较为全面的推荐体验。项目架构清晰，代码组织合理，具有良好的可维护性和可扩展性。 