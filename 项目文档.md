# 基于机器学习的个性化电影推荐系统 - 详细文档

## 1. 项目概述

### 1.1 项目简介

本项目是一个基于机器学习的个性化电影推荐系统，通过微信公众号作为前端交互界面，为用户提供电影搜索、评分和个性化推荐功能。系统主要采用协同过滤算法作为核心推荐引擎，辅以基于内容的推荐算法解决冷启动问题。

### 1.2 技术栈

- **后端语言:** Python 3.8+
- **Web框架:** web.py
- **数据库:** MySQL 8.0
- **核心依赖库:**
  - `pymysql`: MySQL数据库连接
  - `web.py`: 轻量级Web框架
  - `lxml`: XML解析（处理微信消息）
  - `cryptography`: 加解密功能

### 1.3 系统架构

系统采用典型的三层架构设计：

1. **前端层:** 微信公众号（用户通过发送文本消息进行交互）
2. **应用层:** 基于web.py的Web应用（处理请求、执行业务逻辑、调用推荐算法）
3. **数据层:** MySQL数据库（存储电影、用户和评分数据）

## 2. 代码结构与模块组成

### 2.1 目录结构

```
movie_recommender_wechat/
├── .venv/                 # Python虚拟环境
├── app/                   # 应用核心代码
│   ├── __init__.py
│   ├── main.py            # 主应用入口和路由
│   ├── wechat_handler.py  # 微信消息处理
│   ├── db_manager.py      # 数据库操作
│   ├── recommendation_engine.py  # 推荐算法实现
│   ├── config.py          # 配置文件
│   └── utils.py           # 工具函数
├── database_schema.sql    # 数据库结构和示例数据
├── deploy.sh              # 自动部署脚本
├── start.sh               # 启动服务脚本
├── stop.sh                # 停止服务脚本
├── requirements.txt       # 项目依赖
├── README.md              # 项目说明
├── TESTING_GUIDE.md       # 测试指南
└── 部署指南.md             # 部署说明
```

### 2.2 核心模块介绍

#### 2.2.1 `app/main.py`

主应用入口，负责：
- 定义Web路由（接收微信服务器的请求）
- 处理GET请求（微信服务器验证）
- 处理POST请求（接收用户消息并调用处理模块）
- 应用初始化和启动逻辑

#### 2.2.2 `app/wechat_handler.py`

微信消息处理模块，负责：
- 验证微信服务器签名
- 解析XML格式的微信消息
- 构建XML格式的响应消息
- 处理不同类型的用户请求：
  - 电影搜索
  - 电影评分
  - 推荐请求
  - 用户关注/取关事件

#### 2.2.3 `app/db_manager.py`

数据库操作模块，负责：
- 提供数据库连接
- 用户管理（查询、创建）
- 电影操作（根据ID查询、按标题搜索）
- 评分管理（添加、更新、获取用户评分）
- 搜索记录（记录用户搜索历史）
- 为推荐算法提供数据支持

#### 2.2.4 `app/recommendation_engine.py`

推荐算法核心模块，负责：
- 基于用户的协同过滤（User-CF）算法实现
- 基于内容的推荐算法实现（解决冷启动问题）
- 综合推荐逻辑（优先使用协同过滤，不足时用基于内容的推荐补充）

#### 2.2.5 `app/config.py`

配置文件，包含：
- 数据库连接参数
- 微信公众号配置
- 推荐算法参数设置

## 3. 数据库设计

系统使用MySQL数据库，包含以下核心表：

### 3.1 `movies` 表

存储电影基本信息：
- `id`: 自增主键
- `title`: 电影名称
- `douban_rating`: 豆瓣评分
- `rating_count`: 评价人数
- `release_date`: 上映日期/年代
- `actors`: 演员列表
- `directors`: 导演列表
- `genres`: 电影类型
- `plot_summary`: 剧情简介
- `poster_url`: 海报URL（可选）
- `douban_url`: 豆瓣链接（可选）
- `created_at`/`updated_at`: 时间戳

### 3.2 `users` 表

存储用户信息：
- `id`: 自增主键
- `openid`: 微信用户OpenID（唯一）
- `nickname`: 微信昵称（可选）
- `created_at`: 创建时间
- `last_active_at`: 最后活跃时间

### 3.3 `ratings` 表

存储用户对电影的评分：
- `id`: 自增主键
- `user_id`: 用户ID（外键）
- `movie_id`: 电影ID（外键）
- `score`: 评分（0-10分）
- `rated_at`: 评分时间

### 3.4 `search_logs` 表（可选）

记录用户搜索历史：
- `id`: 自增主键
- `user_id`: 用户ID（外键）
- `search_query`: 搜索关键词
- `search_time`: 搜索时间

## 4. 核心功能实现

### 4.1 微信接口对接

系统通过微信公众平台提供的接口与用户交互：

1. **服务器验证：**
   - 接收微信服务器的GET请求
   - 验证签名（`wechat_handler.check_signature`）
   - 返回验证字符串（echostr）

2. **消息处理：**
   - 接收微信服务器的POST请求（XML格式）
   - 解析XML消息（`wechat_handler.parse_xml_message`）
   - 根据消息类型和内容分发到不同处理函数
   - 构建XML响应（`wechat_handler.build_text_response`）

### 4.2 电影搜索功能

用户直接发送电影名称时触发搜索：

1. **处理流程：**
   - 获取/创建用户ID
   - 记录搜索查询
   - 尝试精确匹配（`db_manager.search_movies_by_title_exact`）
   - 若无精确结果，进行模糊匹配（`db_manager.search_movies_by_title_fuzzy`）
   - 格式化电影信息并返回

2. **搜索策略：**
   - 精确匹配：`WHERE title = %s`
   - 模糊匹配：`WHERE title LIKE %s`（按评分排序，限制数量）

### 4.3 电影评分功能

用户发送"评价 电影名 评分"格式的消息时触发：

1. **处理流程：**
   - 解析评分命令（使用正则表达式）
   - 验证评分范围（0-10分）并自动调整
   - 查找电影（处理同名电影问题）
   - 添加或更新评分（`db_manager.add_or_update_rating`）
   - 返回评分成功提示

2. **数据操作：**
   - 检查评分是否存在：`SELECT id FROM ratings WHERE user_id = %s AND movie_id = %s`
   - 更新已有评分：`UPDATE ratings SET score = %s, rated_at = NOW() WHERE...`
   - 添加新评分：`INSERT INTO ratings (user_id, movie_id, score) VALUES (%s, %s, %s)`

### 4.4 电影推荐功能

用户发送"推荐"时触发：

1. **处理流程：**
   - 获取用户评分数量
   - 如果用户没有评分，提示需要先评价电影
   - 调用推荐引擎（`recommendation_engine.generate_recommendations`）
   - 获取推荐电影详情并格式化返回

2. **推荐策略：**
   - 优先使用协同过滤
   - 如果协同过滤结果不足，用基于内容的推荐补充
   - 确保不推荐用户已评分过的电影

### 4.5 用户关注与欢迎

用户关注公众号时触发：

1. **处理流程：**
   - 接收`subscribe`事件
   - 创建用户记录（如不存在）
   - 发送欢迎语和使用说明

## 5. 推荐算法详解

### 5.1 基于用户的协同过滤 (User-CF)

主要实现在`recommendation_engine.get_user_cf_recommendations`函数中：

1. **算法流程：**
   - 获取目标用户的评分记录
   - 获取所有其他用户的评分记录
   - 计算用户相似度（基于共同评分的电影）
   - 选择最相似的N个邻居用户
   - 从邻居的高分电影中生成推荐

2. **相似度计算：**
   系统使用基于评分差平方的相似度计算方法：
   - 找出两个用户共同评分的电影
   - 计算每部电影评分差的平方，求和后除以共同电影数
   - 差异值`area = Σ(score_target_user_i - score_other_user_i)^2 / num_common_movies`
   - 最终相似度`similarity = 1 / (1 + area)`（越大表示越相似）

3. **推荐生成：**
   - 只考虑邻居高分评价的电影（评分 >= 7）
   - 排除目标用户已评分的电影
   - 计算预测评分 = 邻居评分 * 相似度之和 / 相似度总和
   - 按预测评分排序选出Top-N电影

### 5.2 基于内容的推荐算法

主要实现在`recommendation_engine.get_content_based_recommendations`函数中：

1. **算法流程：**
   - 获取用户已评分电影列表
   - 获取高评分电影作为候选（排除已评分的）
   - 按豆瓣评分排序
   - 从前50%的高分电影中随机选择，增加多样性

2. **应用场景：**
   - 新用户（冷启动问题）
   - 用户评分太少，协同过滤无法有效工作
   - 协同过滤推荐数量不足时的补充

### 5.3 综合推荐策略

主要实现在`recommendation_engine.generate_recommendations`函数中：

- 优先使用协同过滤推荐
- 如果协同过滤结果不足，使用基于内容的推荐补充
- 合并两种推荐结果（注意去重）
- 出错时使用基于内容的推荐作为备选方案

## 6. 系统部署

系统提供了自动部署脚本和手动部署指南：

### 6.1 部署脚本

`deploy.sh`实现了自动化部署流程：
- 检查环境和权限
- 创建/激活Python虚拟环境
- 安装项目依赖
- 检查端口占用情况
- 启动应用并监控状态

### 6.2 服务管理

- `start.sh`: 启动服务脚本
- `stop.sh`: 停止服务脚本
- 使用`nohup`命令确保服务在后台运行

## 7. 优化与扩展点

系统在设计和实现中已考虑多个优化方向：

1. **推荐算法优化：**
   - 使用MIN_COMMON_RATINGS参数调整相似度计算的可靠性
   - 实现了多样性策略：从高分电影中随机选择，避免推荐结果单一
   - 冷启动问题的处理：针对新用户提供基于内容的推荐

2. **错误处理和容错：**
   - 完善的异常捕获和日志记录
   - 推荐失败时的备选策略
   - 评分范围自动调整

3. **潜在扩展方向：**
   - 实现基于物品的协同过滤(Item-CF)
   - 添加更复杂的推荐算法（如矩阵分解）
   - 开发管理员界面
   - 电影数据自动更新机制
   - 推荐结果多样性进一步优化

## 8. 总结

本项目实现了一个功能完整的个性化电影推荐系统，通过微信公众号为用户提供直观的交互方式。系统核心功能包括电影搜索、评分和个性化推荐，重点解决了推荐系统中的冷启动问题和数据稀疏性问题。

推荐算法采用了基于用户的协同过滤作为主要策略，辅以基于内容的推荐算法，实现了较为全面的推荐体验。项目架构清晰，代码组织合理，具有良好的可维护性和可扩展性。 